#!/usr/bin/env node
const program = require('../lib/program')

program.process('claims')

const { dim, yellow } = require('chalk')
const parseId = require('../lib/tolerant_id_parser')
const logClaims = require('../lib/log_claims')
const commonErrors = require('../lib/common_errors')
const getLangProps = require('../lib/get_lang_props')
const { isPropertyId, getEntities, isPropertyId, simplify } = require('../lib/wbk')(program)

var [ id, ...filter ] = program.args
var id = id && parseId(id)

var prop, value, pattern
if (isPropertyId(filter[0])) {
  prop = filter[0]
  value = filter[1]
} else {
  pattern = filter.join(' ')
}

const { lang, verbose } = program
const output = require('../lib/output')(program)

if (!(id && lang)) return program.help()

// Working around a weird behavior of commander that inverts arguments
// when an option is passed before
if (id && prop && id[0] === 'P' && prop[0] === 'Q') {
  [ id, prop ] = [ prop, id ]
}

const lightGet = require('../lib/light_get')
const errors_ = require('../lib/errors')

const url = getEntities({ props: 'claims', ids: id })

lightGet(url)
.then(body => {
  const entity = body.entities && body.entities[id]
  if (!entity) return console.log('error: ', body)

  if (isPropertyId(prop) && value != null) {
    const propClaims = entity.claims[prop]
    if (!propClaims) throw new Error(`no claims found for this property: ${prop}`)
    const ids = simplify.propertyClaims(propClaims, { keepIds: true })
      .filter(simplifyClaim => simplifyClaim.value === value)
      .map(simplifyClaim => simplifyClaim.id)
    return output(ids)
  }

  const claims = simplify.claims(entity.claims)
  if (!prop) return logClaims(program, claims, pattern)

  value = claims[prop]
  if (value != null) return output(claims[prop])

  getLangProps(program)
  .then(props => {
    if (!props[prop]) return commonErrors.missingProperty(prop)
    const { label } = props[prop]
    console.log(yellow('no statement found'), label)
  })
})
.catch(errors_.exit)
